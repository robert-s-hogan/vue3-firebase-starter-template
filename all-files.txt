═══════════════════════════════════════════════
📄 FILE: ./eslint.config.js
───────────────────────────────────────────────
// eslint.config.js
import { defineConfig } from 'eslint/config'
import js from '@eslint/js'
import pluginVue from 'eslint-plugin-vue'
import tsESLint from '@typescript-eslint/eslint-plugin'
import tsParser from '@typescript-eslint/parser'
import vueParser from 'vue-eslint-parser'
import pluginPrettier from 'eslint-plugin-prettier'
import cypressPlugin from 'eslint-plugin-cypress'
import tailwindCustomPlugin from './scripts/eslint-plugin-tailwind-custom-colors.cjs'

export default defineConfig([
  // --- Main config for JS, TS, and Vue files ---
  {
    // Target the primary source files
    files: ['**/*.{js,ts,vue}'],

    // Ignores apply to this specific config object's file pattern.
    // They also help ESLint's overall ignore behavior.
    ignores: [
      'node_modules/**',
      'dist/**',
      // Keep existing ignores for config/script files from this block
      '*.config.js',
      '*.config.ts',
      'scripts/**',
      'check-pnpm.js',
      // Explicitly ignore test files from *this* block, handled in their own block
      'cypress/**',
      'src/**/*.cy.{js,ts}',
    ],

    plugins: {
      '@typescript-eslint': tsESLint,
      vue: pluginVue,
      prettier: pluginPrettier,
      // Remove cypress plugin from here, apply only in test block
      // cypress: cypressPlugin,
      'tailwind-custom-colors': tailwindCustomPlugin,
    },

    languageOptions: {
      // Use vue-eslint-parser for this block covering .vue files
      // It will handle passing TS files to tsParser.
      parser: vueParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        // Tell vue-eslint-parser to use tsParser for the <script> block
        parser: tsParser,
        extraFileExtensions: ['.vue'],
        // project: ['./tsconfig.json'], // Add if TS rules need type info
        // tsconfigRootDir: __dirname, // Add if TS rules need type info
      },
      globals: {
        console: 'readonly', // Console is available in most environments
      },
    },

    settings: {
      // Remove cypress settings from here
      // ...cypressPlugin.configs.recommended.settings,
    },

    rules: {
      ...js.configs.recommended.rules, // Base JS rules
      ...pluginVue.configs['flat/recommended'].rules, // Vue recommended rules (applied to .vue files)
      ...tsESLint.configs.recommended.rules, // Base TS rules (applied via tsParser)

      // Customize unused vars rule - allow leading underscore for args/caught errors
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_', caughtErrorsIgnorePattern: '^_' },
      ],
      'prettier/prettier': 'error', // Prettier integration rule
      'tailwind-custom-colors/no-non-theme-tailwind-colors': 'warn', // Custom plugin rule

      // The no-console rule allows specific console methods
      'no-console': ['warn', { allow: ['warn', 'error', 'log'] }],

      // Disable no-undef as we are explicitly defining globals where needed
      // and relying on TS for other undefined checks in TS files.
      'no-undef': 'off',
    },
  },

  // --- Special config for Cypress & Test files (js, ts) ---
  // These files were ignored in the first block, now configured specifically.
  {
    files: [
      'cypress/**/*.{js,ts}', // Cypress specific files
      'src/**/*.cy.{js,ts}', // Component/service test files
    ],
    // No ignores needed here, files pattern is specific.
    plugins: {
      '@typescript-eslint': tsESLint, // Needed for TS test files
      cypress: cypressPlugin, // Needed for Cypress rules and globals
    },
    languageOptions: {
      // Use tsParser for TS test files (and works for JS test files)
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        // project: ['./tsconfig.json'], // Add if TS rules in tests need type info
        // tsconfigRootDir: __dirname, // Add if TS rules in tests need type info
      },
      globals: {
        // Declare Cypress, Mocha, Chai, Sinon, and other test globals explicitly
        Cypress: 'readonly',
        cy: 'readonly',
        describe: 'readonly', // Mocha global
        it: 'readonly', // Mocha global
        expect: 'readonly', // Chai global (used by Cypress/Mocha)
        assert: 'readonly', // Chai global
        before: 'readonly', // Mocha global
        after: 'readonly', // Mocha global
        beforeEach: 'readonly', // Mocha global
        afterEach: 'readonly', // Mocha global
        sinon: 'readonly', // Sinon global (seen in authServices.cy.js)
        MouseEvent: 'readonly', // Standard DOM global used in BaseButton.cy.ts
        console: 'readonly', // Console is also used in tests
      },
    },
    settings: {
      // Apply cypress recommended settings here for globals etc.
      ...cypressPlugin.configs.recommended.settings,
    },
    rules: {
      // Apply Cypress recommended rules
      ...cypressPlugin.configs.recommended.rules,

      // Disable the no-undef rule for test files as we define globals above
      'no-undef': 'off',

      // Disable @typescript-eslint/no-unused-expressions in test files
      // This rule commonly flags 'expect(...)' assertions.
      '@typescript-eslint/no-unused-expressions': 'off',

      // You might want different unused var rules in tests (e.g., warn instead of error)
      // '@typescript-eslint/no-unused-vars': 'warn', // Example: Change to warn
    },
  },

  // --- Config for JS config/script files ---
  // These files were ignored in the first block, now configured specifically.
  {
    files: ['*.config.js', '*.config.ts', 'scripts/**/*.js', 'check-pnpm.js'],
    // No ignores needed here, files pattern is specific.
    plugins: {
      prettier: pluginPrettier, // If you want prettier in config files
    },
    languageOptions: {
      // Explicitly *do not* use tsParser for these files, as they are plain JS or config TS
      // Let ESLint default parser handle them or use espree implicitly.
      parser: undefined, // Or parser: null
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module', // Use module syntax for modern config files
      },
      globals: {
        // Add Node.js globals typically available in config/script files
        __dirname: 'readonly',
        process: 'readonly',
        module: 'readonly',
        require: 'readonly',
        console: 'readonly',
      },
    },
    rules: {
      ...js.configs.recommended.rules, // Apply base JS rules
      'prettier/prettier': 'error', // Apply Prettier rule

      // Disable TS rules and no-undef as they don't apply here
      '@typescript-eslint/no-unused-vars': 'off',
      'no-undef': 'off', // Disable no-undef as Node globals might not be covered by base js config
    },
  },

  // --- Specific config to handle/ignore .d.ts files ---
  // This is a fallback block. If .d.ts files somehow aren't fully ignored
  // by the 'ignores' in the first block and cause parsing errors, this block
  // explicitly targets them and prevents any parser from running.
  // --- Specific config to handle/ignore .d.ts files ---
  // --- Specific config to handle/ignore .d.ts files ---
  {
    files: ['vite-env.d.ts', '**/*.d.ts'],
    languageOptions: {
      parser: undefined, // Or parser: null
    },
    rules: {
      // Turn off all potentially conflicting rules for these files.
      // Since no parser runs, most rules won't apply anyway, but this is safer.
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off', // .d.ts files can have types only used locally
      'no-undef': 'off',
      'prettier/prettier': 'off', // Ensure prettier doesn't try to format them
      // You could add 'off' for other specific plugin rules if necessary
    }, // <--- This brace closes the 'rules' object. GOOD.


═══════════════════════════════════════════════
📄 FILE: ./src/assets/tailwind.css
───────────────────────────────────────────────
@tailwind base;
@tailwind components;
@tailwind utilities;


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseAlert/BaseAlert.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseAlert/BaseAlert.cy.ts
import { mount } from '@cypress/vue'
import BaseAlert from './BaseAlert.vue' // Assuming BaseAlert.vue is the component file

// Define the possible variant types for better type safety (Optional but recommended)
type AlertVariant = 'info' | 'success' | 'warning' | 'danger'

describe('BaseAlert Component', () => {
  it('renders correctly with info variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'info' as AlertVariant, // Type assertion for clarity
      },
      slots: {
        default: 'Info alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-info-light')
      .and('have.class', 'text-info-dark')
  })

  it('renders correctly with success variant', () => {
    // Note: There might be a typo in your original JS test: 'text-info-darkabg-success-light'
    // Assuming it should be 'bg-success-light'
    mount(BaseAlert, {
      props: {
        variant: 'success' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Success alert',
      },
    })
    cy.get('[role="alert"]')
      // Corrected class name based on assumption
      .should('have.class', 'bg-success-light')
      .and('have.class', 'text-success-dark')
  })

  it('renders correctly with warning variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'warning' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Warning alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-warning-light')
      .and('have.class', 'text-warning-dark')
  })

  it('renders correctly with danger variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'danger' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Danger alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-error-light')
      .and('have.class', 'text-error-dark')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseAvatar/BaseAvatar.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseAvatar/BaseAvatar.cy.ts
import { mount } from '@cypress/vue'
import BaseAvatar from './BaseAvatar.vue'

describe('BaseAvatar', () => {
  it('renders image when src is provided', () => {
    const testUrl = 'https://via.placeholder.com/150'
    mount(BaseAvatar, {
      props: { src: testUrl, alt: 'Test', name: 'Jane Doe' },
    })
    cy.get('img')
      .should('have.attr', 'src', testUrl)
      .and('have.attr', 'alt', 'Test')
  })

  it('falls back to initials on error', () => {
    cy.intercept('GET', '**/broken.png', { forceNetworkError: true })
    mount(BaseAvatar, { props: { src: 'broken.png', name: 'Jane Doe' } })
    cy.get('[data-cy="avatar"] img').should('exist')
    // trigger error
    cy.get('[data-cy="avatar"] img').invoke('error')
    cy.get('[data-cy="avatar"] span').should('have.text', 'JD')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseBadge/BaseBadge.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseBadge/BaseBadge.cy.ts
import { mount } from '@cypress/vue'
import BaseBadge from './BaseBadge.vue'

describe('BaseBadge', () => {
  it('renders the label', () => {
    mount(BaseBadge, { props: { label: 'Hello' } })
    cy.get('[data-cy="badge"]').should('have.text', 'Hello')
  })

  it('applies default styling', () => {
    mount(BaseBadge, { props: { label: 'New' } })
    cy.get('[data-cy="badge"]')
      .should('have.class', 'bg-muted')
      .and('have.class', 'text-text-primary')
  })

  it('applies success variant', () => {
    mount(BaseBadge, { props: { label: 'Done', variant: 'success' } })
    cy.get('[data-cy="badge"]')
      .should('have.class', 'bg-success-light')
      .and('have.class', 'text-success-dark')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseButton/BaseButton.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseButton/BaseButton.cy.ts
import { mount } from '@cypress/vue'
import BaseButton from './BaseButton.vue' // Ensure this path is correct
import type { DefineComponent } from 'vue'

// Define the possible variant types for better type safety
type ButtonVariant = 'primary' | 'secondary' | 'primaryOutlined'

// Define the props structure for type checking when creating the props object
// (We won't use this as a generic for mount anymore)
interface BaseButtonProps {
  variant?: ButtonVariant
  loading?: boolean
  disabled?: boolean // Added based on your component code
  class?: string | string[] | Record<string, boolean> // Added based on your component code
  // Add any other specific event handlers if needed, e.g., onClick?: (event: MouseEvent) => void;
}

describe('BaseButton Component', () => {
  // Helper function to type the props object (Optional but can help)
  const createProps = (props: BaseButtonProps) => props

  it('renders correctly with primary variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primary' }),
      slots: {
        default: 'Primary Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-primary')
      .and('have.class', 'text-white')
      .and('not.have.class', 'opacity-50') // Check it's not disabled/loading
      .and('not.have.class', 'opacity-70')
  })

  it('renders correctly with secondary variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'secondary' }),
      slots: {
        default: 'Secondary Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-secondary')
      .and('have.class', 'text-white')
      .and('not.have.class', 'opacity-50')
      .and('not.have.class', 'opacity-70')
  })

  it('renders correctly with primaryOutlined variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primaryOutlined' }),
      slots: {
        default: 'Outlined Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'border')
      .and('have.class', 'text-primary')
      .and('have.class', 'bg-white') // Check other expected classes
      .and('not.have.class', 'opacity-50')
      .and('not.have.class', 'opacity-70')
  })

  it('displays spinner and correct classes when loading is true', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: true, variant: 'primary' }),
      slots: {
        default: 'Primary Button', // Slot content exists even if hidden
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'opacity-70')
      .and('have.class', 'cursor-wait') // Check cursor class from your component
      .and('be.disabled') // Check disabled attribute

    cy.get('[data-cy="button"] svg.animate-spin').should('exist')
    // The span with slot content might still be in the DOM but hidden,
    // depending on how v-if/v-show is used. If it's truly removed by v-if:
    // cy.get('[data-cy="button"] span').should('not.exist');
    // If it's hidden (e.g., display: none), check visibility:
    cy.get('[data-cy="button"] > span').should('not.be.visible') // Check direct child span specifically

    // Verify spinner has text-white class (or adapt based on variant)
    cy.get('[data-cy="button"] svg.animate-spin').should(
      'have.class',
      'text-white',
    )
  })

  it('applies disabled classes and attribute when disabled is true', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ disabled: true, variant: 'primary' }),
      slots: {
        default: 'Disabled Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'opacity-50')
      .and('have.class', 'cursor-not-allowed')
      .and('be.disabled') // Check the disabled attribute

    // Ensure spinner is NOT shown
    cy.get('[data-cy="button"] svg.animate-spin').should('not.exist')
    cy.get('[data-cy="button"] > span').should('be.visible')
  })

  it('emits click event when clicked and not loading/disabled', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: false, disabled: false }),
      slots: {
        default: 'Clickable Button',
      },
    }).then(({ wrapper }) => {
      cy.get('[data-cy="button"]').click()
      cy.get('[data-cy="button"]').then(() => {
        const emittedEvents = wrapper.emitted('click')
        expect(emittedEvents).to.exist
        expect(emittedEvents).to.have.length(1)
        // Check payload is an array containing the original MouseEvent
        expect(emittedEvents?.[0]?.[0]).to.be.instanceOf(MouseEvent)
      })
    })
  })

  it('does NOT emit click event when loading', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: true }),
      slots: { default: 'Loading' },
    }).then(({ wrapper }) => {
      // Use { force: true } because Cypress won't click disabled elements by default
      cy.get('[data-cy="button"]').click({ force: true })

      cy.get('[data-cy="button"]').then(() => {
        expect(wrapper.emitted('click')).to.not.exist
      })
    })
  })

  it('does NOT emit click event when disabled', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ disabled: true }),
      slots: { default: 'Disabled' },
    }).then(({ wrapper }) => {
      // Use { force: true } because Cypress won't click disabled elements by default
      cy.get('[data-cy="button"]').click({ force: true })

      cy.get('[data-cy="button"]').then(() => {
        expect(wrapper.emitted('click')).to.not.exist
      })
    })
  })

  it('merges passed classes correctly', () => {
    const extraClass = 'my-extra-class'
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primary', class: extraClass }),
      slots: { default: 'Extra Class Button' },
    })

    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-primary') // Check base variant class
      .and('have.class', extraClass) // Check merged class
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseCard/BaseCard.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseCard/BaseCard.cy.ts

import { mount } from '@cypress/vue'
import BaseCard from './BaseCard.vue' // Import the Vue component

describe('BaseCard Component', () => {
  it('renders card content correctly with expected styles', () => {
    const slotContent = '<p>This is the card content</p>' // Define slot content

    // Mount the component, passing the slot content
    mount(BaseCard, {
      slots: {
        default: slotContent, // Use the defined variable
      },
    })

    // Select the component's root element (assuming it's the div)
    // Chain the class assertions for better readability
    cy.get('div.bg-white.shadow-md.rounded.p-6') // More specific selector
      .should('exist') // Make sure the element itself exists with these classes
      .and('have.class', 'bg-white')
      .and('have.class', 'shadow-md')
      .and('have.class', 'rounded')
      .and('have.class', 'p-6')
      // Check the content *within* this div
      .find('p') // Find the paragraph element within the card
      .should('have.text', 'This is the card content') // Use have.text for exact match

    /* Alternative approach: Add a data-cy attribute for robustness */
    /*
    // In BaseCard.vue: <div data-cy="base-card" class="bg-white ...">
    mount(BaseCard, {
        slots: { default: slotContent }
    });

    cy.get('[data-cy="base-card"]')
        .should('have.class', 'bg-white')
        .and('have.class', 'shadow-md')
        .and('have.class', 'rounded')
        .and('have.class', 'p-6')
        .find('p')
        .should('have.text', 'This is the card content');
    */
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseIconButton/BaseIconButtyon.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseIconButton/BaseIconButton.cy.ts
import { mount } from '@cypress/vue'
import BaseIconButton from './BaseIconButton.vue'

const DummyIcon = {
  template: '<svg data-cy="icon"></svg>',
}

describe('BaseIconButton', () => {
  it('renders an icon and has correct aria-label', () => {
    mount(BaseIconButton, {
      props: { label: 'Close' },
      slots: { default: DummyIcon },
    })
    cy.get('[data-cy="icon"]').should('exist')
    cy.get('button').should('have.attr', 'aria-label', 'Close')
  })

  it('emits click event', () => {
    const onClick = cy.stub()
    mount(BaseIconButton, { props: { label: 'Click', onClick } })
    cy.get('button').click()
    cy.get('button').then(() => {
      expect(onClick).to.have.been.called
    })
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseInput/BaseInput.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseInput/BaseInput.cy.ts

import { mount } from '@cypress/vue'
import BaseInput from './BaseInput.vue'

describe('BaseInput Component', () => {
  // Define base props that are required by the component's type definition
  // Assuming 'type' and 'disabled' are the required ones based on the error
  const requiredBaseProps = {
    type: 'text', // Provide a default type if required
    disabled: false, // Provide a default disabled state if required
    modelValue: '', // Include modelValue with a default empty string
  }

  it('renders input with the correct type and placeholder', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Start with the required base props
        type: 'text', // Override type for this specific test
        placeholder: 'Enter your name',
        // disabled: false, // Already included in requiredBaseProps default
      },
    })
    cy.get('input').should('have.attr', 'type', 'text')
    cy.get('input').should('have.attr', 'placeholder', 'Enter your name')
    cy.get('input').should('not.be.disabled') // Also good to assert the default disabled state
  })

  it('emits the correct value on input', () => {
    const onUpdateSpy = cy.spy().as('onUpdateSpy')

    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        modelValue: '', // This test focuses on modelValue, explicitly setting it
        'onUpdate:modelValue': onUpdateSpy,
        // type: 'text', // Already included in requiredBaseProps default
        // disabled: false, // Already included in requiredBaseProps default
      },
    })

    cy.get('input').type('Hello World')

    cy.get('@onUpdateSpy').should('have.been.calledOnceWith', 'Hello World')
  })

  it('applies correct classes for disabled state', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        disabled: true, // Override disabled for this specific test
        // type: 'text', // Already included in requiredBaseProps default
        // modelValue: '', // Already included in requiredBaseProps default
      },
    })
    cy.get('input').should('have.class', 'opacity-50')
    cy.get('input').should('have.class', 'cursor-not-allowed')
    cy.get('input').should('be.disabled')
  })

  it('applies correct classes for password type', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        type: 'password', // Override type for this specific test
        // disabled: false, // Already included in requiredBaseProps default
        // modelValue: '', // Already included in requiredBaseProps default
      },
    })
    // Note: Double-check if border-error-light/focus:ring-error-light
    // is *only* for password type or password type with an error.
    // Assuming it's just for password type based on the original test comment.
    cy.get('input').should('have.class', 'border-error-light')
    cy.get('input').should('have.class', 'focus:ring-error-light')
    cy.get('input').should('have.attr', 'type', 'password') // Assert type is set
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseInputGroup/BaseInputGroup.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseInputGroup/BaseInputGroup.cy.ts
import { mount } from '@cypress/vue'
import BaseInputGroup from './BaseInputGroup.vue'

// Mock BaseInput for isolation
import BaseInput from '../BaseInput/BaseInput.vue'

describe('BaseInputGroup', () => {
  it('renders label, input, and help text', () => {
    mount(BaseInputGroup, {
      props: {
        id: 'test',
        label: 'Name',
        modelValue: '',
        help: 'Enter your name',
      },
      global: { components: { BaseInput } },
    })
    cy.get('label').should('have.attr', 'for', 'test').and('have.text', 'Name')
    cy.get('input').should('have.attr', 'id', 'test')
    cy.get('p').should('have.text', 'Enter your name')
  })

  it('emits update:modelValue on input', () => {
    const onUpdate = cy.spy().as('onUpdate')
    mount(BaseInputGroup, {
      props: {
        id: 'test',
        label: 'Name',
        modelValue: '',
        'onUpdate:modelValue': onUpdate,
      },
      global: { components: { BaseInput } },
    })
    cy.get('input').type('Vue')
    cy.get('@onUpdate').should('have.been.calledWith', 'Vue')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseLink/BaseLink.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseLink/BaseLink.cy.ts

import { mount } from '@cypress/vue'
import { createRouter, createWebHistory } from 'vue-router'
import BaseLink from './BaseLink.vue'

// Setup routes for testing the router-link component
const routes = [
  { path: '/', component: { template: '<div>Home Page</div>' } },
  { path: '/about', component: { template: '<div>About Page</div>' } },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

describe('BaseLink Component', () => {
  it('renders with the correct `to` attribute', () => {
    mount(BaseLink, {
      global: {
        plugins: [router],
      },
      props: {
        to: '/about',
      },
      slots: {
        default: 'Go to About',
      },
    })

    cy.get('a').should('have.attr', 'href', '/about')
    cy.get('a').should('contain.text', 'Go to About')
  })

  it('navigates correctly when clicked', () => {
    mount(BaseLink, {
      global: {
        plugins: [router],
      },
      props: {
        to: '/about',
      },
      slots: {
        default: 'Go to About',
      },
    })

    cy.get('a').click()
    cy.url().should('include', '/about')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseLoading/BaseLoading.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseLoading/BaseLoading.cy.ts

import { mount } from '@cypress/vue'
import BaseLoading from './BaseLoading.vue'

describe('BaseLoading Component', () => {
  it('renders the loading spinner', () => {
    mount(BaseLoading)

    // Check if the loader div is present
    cy.get('.loader')
      .should('exist')
      .and('have.class', 'ease-linear')
      .and('have.class', 'rounded-full')
      .and('have.class', 'border-8')
  })

  it('has the correct fixed position and overlay', () => {
    mount(BaseLoading)

    // Make sure we're targeting the outer overlay div with the 'fixed' class
    cy.get('div.fixed')
      .should('have.class', 'inset-0')
      .and('have.class', 'bg-black')
      .and('have.class', 'bg-opacity-50')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseModal/BaseModal.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseModal.cy.ts

import { mount } from '@cypress/vue'
import BaseModal from './BaseModal.vue'

describe('BaseModal Component', () => {
  it('renders the modal when visible is true', () => {
    mount(BaseModal, {
      props: {
        visible: true,
      },
    })

    // Assert the modal is rendered
    cy.get('div.fixed')
      .should('have.class', 'inset-0')
      .and('have.class', 'bg-black')
      .and('have.class', 'bg-opacity-50')

    cy.get('div.bg-white')
      .should('exist')
      .and('have.class', 'p-6')
      .and('have.class', 'rounded')
  })

  it('emits the close event when close button is clicked', () => {
    // Mount the component and pass a function as a prop to listen for 'close' event
    const onCloseSpy = cy.spy().as('onCloseSpy')

    mount(BaseModal, {
      props: {
        visible: true,
        onClose: onCloseSpy, // Attach the spy function to the close event
      },
    })

    // Click on the close button
    cy.get('button').contains('X').click()

    // Check if the event 'close' was called
    cy.get('@onCloseSpy').should('have.been.calledOnce')
  })

  it('does not render the modal when visible is false', () => {
    mount(BaseModal, {
      props: {
        visible: false,
      },
    })

    // Assert that the modal does not exist
    cy.get('div.fixed').should('not.exist')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseSwitch/BaseSwitch.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseSwitch/BaseSwitch.cy.ts
import { mount } from '@cypress/vue'
import BaseSwitch from './BaseSwitch.vue'

describe('BaseSwitch', () => {
  it('renders unchecked by default', () => {
    mount(BaseSwitch, { props: { modelValue: false } })
    cy.get('input[type="checkbox"]').should('not.be.checked')
  })

  it('toggles and emits update:modelValue on change', () => {
    const onUpdate = cy.spy().as('onUpdate')
    mount(BaseSwitch, {
      props: { modelValue: false, 'onUpdate:modelValue': onUpdate },
    })
    cy.get('input[type="checkbox"]').check({ force: true })
    cy.get('@onUpdate').should('have.been.calledWith', true)
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseTooltip/BaseTooltip.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseTooltip/BaseTooltip.cy.ts
import { mount } from '@cypress/vue'
import BaseTooltip from './BaseTooltip.vue'

describe('BaseTooltip', () => {
  it('shows tooltip text on hover', () => {
    mount(BaseTooltip, {
      props: { text: 'Help info' },
      slots: { default: '<button>Hover me</button>' },
    })
    cy.get('[data-cy="tooltip"]').should('not.exist')
    cy.get('button').trigger('mouseenter')
    cy.get('[data-cy="tooltip"]').should('have.text', 'Help info')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/index.ts
───────────────────────────────────────────────
export { default as BaseAlert } from './BaseAlert/BaseAlert.vue'
export { default as BaseButton } from './BaseButton/BaseButton.vue'
export { default as BaseCard } from './BaseCard/BaseCard.vue'
export { default as BaseInput } from './BaseInput/BaseInput.vue'
export { default as BaseLink } from './BaseLink/BaseLink.vue'
export { default as BaseLoading } from './BaseLoading/BaseLoading.vue'
export { default as BaseModal } from './BaseModal/BaseModal.vue'
export { default as ToastIcon } from './ToastIcon/ToastIcon.vue'
export { default as ToastMessage } from './ToastMessage/ToastMessage.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/ToastIcon/ToastIcon.cy.ts
───────────────────────────────────────────────
// src/components/atoms/ToastIcon/ToastIcon.cy.ts
import { mount } from '@cypress/vue'
import ToastIcon from './ToastIcon.vue'
describe('ToastIcon', () => {
  it('emits close when clicked', () => {
    const onClose = cy.spy().as('onClose')
    mount(ToastIcon, { props: { onClose } })
    cy.get('button').click()
    cy.get('@onClose').should('have.been.called')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/ToastMessage/ToastMessage.cy.ts
───────────────────────────────────────────────
// src/components/atoms/ToastMessage/ToastMessage.cy.ts
import { mount } from '@cypress/vue'
import ToastMessage from './ToastMessage.vue'
describe('ToastMessage', () => {
  it('renders slot content', () => {
    mount(ToastMessage, { slots: { default: 'Hello Toast' } })
    cy.get('[data-cy="toast-message"]').should('have.text', 'Hello Toast')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/index.ts
───────────────────────────────────────────────
export * from './atoms'
export * from './molecules'
export * from './organisms'


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/BaseNavigation/BaseNavigation.cy.ts
───────────────────────────────────────────────
import { mount } from '@cypress/vue'
import BaseNavigation from './BaseNavigation.vue'
import { createMemoryHistory, createRouter } from 'vue-router'
import BaseLink from '@/components/atoms/BaseLink/BaseLink.vue'

// Define the routes
const routes = [
  { path: '/dashboard', component: { template: '<div>Dashboard Page</div>' } },
]
const router = createRouter({
  history: createMemoryHistory(),
  routes,
})

describe('BaseNavigation Component', () => {
  it('renders the Dashboard link when authenticated', () => {
    mount(BaseNavigation, {
      props: {
        isAuthenticated: true,
      },
      global: {
        plugins: [router],
        components: {
          Link: BaseLink, // Register BaseLink as a global component
        },
      },
    })

    // Ensure the dashboard link is visible
    cy.get('a').should('contain.text', 'Dashboard')
    cy.get('a').should('have.attr', 'href', '/dashboard')
  })

  it('does not render the Dashboard link when not authenticated', () => {
    mount(BaseNavigation, {
      props: {
        isAuthenticated: false,
      },
      global: {
        plugins: [router],
        components: {
          Link: BaseLink,
        },
      },
    })

    // Ensure the dashboard link is not visible
    cy.get('a').should('not.exist')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/FormField/FormField.cy.ts
───────────────────────────────────────────────
import { mount } from '@cypress/vue'
import FormField from './FormField.vue'
import BaseInput from '@/components/atoms/BaseInput/BaseInput.vue'

describe('FormField Component', () => {
  it('renders the label and input correctly', () => {
    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Test Label',
        modelValue: '',
        placeholder: 'Enter text',
      },
      global: {
        components: { BaseInput },
      },
    })

    // Check that the label and input are rendered correctly
    cy.get('label').should('have.text', 'Test Label')
    cy.get('input')
      .should('have.attr', 'placeholder', 'Enter text')
      .should('have.attr', 'id', 'test-input')
  })

  it('updates the value when typing', () => {
    const onUpdateSpy = cy.spy().as('onUpdateSpy')

    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Test Label',
        modelValue: '',
        placeholder: 'Enter text',
        'onUpdate:modelValue': onUpdateSpy,
      },
      global: {
        components: { BaseInput },
      },
    })

    cy.get('input').type('Hello World')
    cy.get('@onUpdateSpy').should('have.been.calledWith', 'Hello World')
  })

  it('handles disabled state correctly', () => {
    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Disabled Input',
        modelValue: '',
        disabled: true,
      },
      global: {
        components: { BaseInput },
      },
    })

    cy.get('input').should('be.disabled')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/FormNavigation/FormNavigation.cy.ts
───────────────────────────────────────────────
// src/components/molecules/FormNavigation/FormNavigation.cy.ts
import { mount } from '@cypress/vue'
import FormNavigation from './FormNavigation.vue'

describe('FormNavigation', () => {
  it('emits back and next events when clicked', () => {
    const onBack = cy.spy().as('back')
    const onNext = cy.spy().as('next')
    mount(FormNavigation, {
      props: { disableBack: false, disableNext: false, onBack, onNext },
    })
    cy.get('[data-cy="back-button"]').click()
    cy.get('[data-cy="back-button"]').then(() => {
      expect(onBack).to.have.been.called
    })
    cy.get('[data-cy="next-button"]').click()
    cy.get('[data-cy="next-button"]').then(() => {
      expect(onNext).to.have.been.called
    })
  })

  it('disables buttons based on props', () => {
    mount(FormNavigation, { props: { disableBack: true, disableNext: true } })
    cy.get('[data-cy="back-button"]').should('be.disabled')
    cy.get('[data-cy="next-button"]').should('be.disabled')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/FormStep/FormStep.cy.ts
───────────────────────────────────────────────
// src/components/molecules/FormStep/FormStep.cy.ts
import { mount } from '@cypress/vue'
import FormStep from './FormStep.vue'

describe('FormStep', () => {
  it('displays step number and title', () => {
    mount(FormStep, { props: { step: 2, title: 'Profile Info' } })
    cy.get('[data-cy="form-step"] span').should('have.text', '2')
    cy.get('[data-cy="form-step"] h3').should('have.text', 'Profile Info')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/index.ts
───────────────────────────────────────────────
export { default as AuthButton } from './AuthButton/AuthButton.vue'
export { default as BaseNavigation } from './BaseNavigation/BaseNavigation.vue'
export { default as FormField } from './FormField/FormField.vue'
export { default as Toast } from './Toast/Toast.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/ProgressIndicator/ProgressIndicator.cy.ts
───────────────────────────────────────────────
// src/components/molecules/ProgressIndicator/ProgressIndicator.cy.ts
import { mount } from '@cypress/vue'
import ProgressIndicator from './ProgressIndicator.vue'

describe('ProgressIndicator', () => {
  it('renders progress bar with correct percentage width', () => {
    mount(ProgressIndicator, { props: { totalSteps: 5, currentStep: 2 } })
    cy.get('[data-cy="progress-indicator"] div.bg-primary').should(
      'have.attr',
      'style',
      'width: 40%;',
    )
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/Toast/Toast.cy.ts
───────────────────────────────────────────────
// src/components/molecules/Toast/Toast.cy.ts
import { mount } from '@cypress/vue'
import Toast from './Toast.vue'
describe('Toast', () => {
  it('renders with default variant and handles close', () => {
    const onClose = cy.spy().as('onClose')
    mount(Toast, {
      props: { onClose },
      slots: { default: 'Info occurred' },
    })
    cy.get('[role=alert]')
      .should('have.class', 'bg-info-light')
      .and('have.class', 'text-info-dark')
    cy.get('[data-cy="toast-message"]').should('have.text', 'Info occurred')
    cy.get('button').click()
    cy.get('@onClose').should('have.been.called')
  })
  it('applies error variant classes', () => {
    mount(Toast, {
      props: { variant: 'error' },
      slots: { default: 'Error happened' },
    })
    cy.get('[role=alert]')
      .should('have.class', 'bg-error-light')
      .and('have.class', 'text-error-dark')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/BaseFooter/BaseFooter.cy.ts
───────────────────────────────────────────────
// src/components/organisms/BaseFooter/BaseFooter.cy.ts
import { mount } from '@cypress/vue'
import BaseFooter from './BaseFooter.vue'

describe('BaseFooter', () => {
  it('renders default slot content', () => {
    mount(BaseFooter)
    cy.get('[data-cy="footer"]')
      .should('exist')
      .and('contain.text', '© 2025 Your Company')
  })

  it('renders custom slot content', () => {
    const customText = 'Custom Footer'
    mount(BaseFooter, { slots: { default: customText } })
    cy.get('[data-cy="footer"]').should('contain.text', customText)
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/BaseHeader/BaseHeader.cy.ts
───────────────────────────────────────────────
// src/components/organisms/BaseHeader/BaseHeader.cy.ts
import { mount } from '@cypress/vue'
import BaseHeader from './BaseHeader.vue'

describe('BaseHeader', () => {
  it('renders default slot content', () => {
    const defaultContent = 'My Header'
    mount(BaseHeader, { slots: { default: defaultContent } })
    cy.get('header').should('exist').and('contain.text', defaultContent)
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/index.ts
───────────────────────────────────────────────
// src/components/organisms/index.js
export { default as BaseFooter } from './BaseFooter/BaseFooter.vue'
export { default as BaseHeader } from './BaseHeader/BaseHeader.vue'
export { default as MultiStepForm } from './MultiStepForm/MultiStepForm.vue'
export { default as ToastContainer } from './ToastContainer/ToastContainer.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/MultiStepForm/MultiStepForm.cy.ts
───────────────────────────────────────────────
// src/components/organisms/MultiStepForm/MultiStepForm.cy.ts
import { mount } from '@cypress/vue'
import MultiStepForm from './MultiStepForm.vue'
import type { Step } from './MultiStepForm.vue'
import { defineComponent } from 'vue'

describe('MultiStepForm', () => {
  it('navigates steps and emits submit on final next', () => {
    const onSubmit = cy.spy().as('submit')
    const StepOne = defineComponent({
      template: '<div data-cy="step-one">One</div>',
    })
    const StepTwo = defineComponent({
      template: '<div data-cy="step-two">Two</div>',
    })

    const steps: Step[] = [
      { key: 'one', title: 'First', component: StepOne },
      { key: 'two', title: 'Second', component: StepTwo },
    ]

    mount(MultiStepForm, { props: { steps, onSubmit } })

    cy.get('[data-cy="step-one"]').should('exist')
    cy.get('[data-cy="next-button"]').click()
    cy.get('[data-cy="step-two"]').should('exist')
    cy.get('[data-cy="next-button"]').click()
    cy.get('@submit').should('have.been.calledWithMatch', {
      one: undefined,
      two: undefined,
    })
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/ToastContainer/ToastContainer.cy.ts
───────────────────────────────────────────────
// src/components/organisms/ToastContainer/ToastContainer.cy.ts
import { mount } from '@cypress/vue'
import ToastContainer, { addToast } from './ToastContainer.vue'
describe('ToastContainer', () => {
  beforeEach(() => cy.clock())
  it('adds and auto-dismisses toasts', () => {
    mount(ToastContainer)
    addToast('Success!', 'success', 1000)
    cy.tick(0)
    cy.get('[data-cy="toast"]')
      .should('have.length', 1)
      .and('contain.text', 'Success!')
      .and('have.class', 'bg-success-light')
      .and('have.class', 'text-success-dark')
    cy.tick(1000)
    cy.get('[data-cy="toast"]').should('not.exist')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/composables/useAuth.ts
───────────────────────────────────────────────
// src/composables/useAuth.ts
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { auth } from '@/firebase/firebaseConfig'
import {
  login as loginService,
  register as registerService,
  logout as logoutService,
  loginWithGoogle as googleService,
} from '@/services/authServices'
import type { FirebaseError } from 'firebase/app'
import { addToast } from './useToast'

const firebaseMessages: Record<string, string> = {
  'auth/email-already-in-use': 'This email is already registered.',
  'auth/wrong-password': 'Incorrect password. Please try again.',
  'auth/user-not-found': 'No account found with that email.',
  // …etc
}

export function useAuth() {
  const router = useRouter()
  const loading = ref(false)

  async function login(email: string, password: string) {
    loading.value = true
    try {
      await loginService(auth, email, password)
      addToast('Welcome back!', 'success')
      return router.push({ name: 'Dashboard' })
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    } finally {
      loading.value = false
    }
  }

  async function loginWithGoogle() {
    loading.value = true
    try {
      const user = await googleService(auth)
      addToast(`Welcome, ${user.email}!`, 'success')
      return router.push({ name: 'Dashboard' })
    } catch (err: unknown) {
      const e = err as FirebaseError
      addToast(e.message || 'Google login failed.', 'error')
      throw e
    } finally {
      loading.value = false
    }
  }

  async function register(email: string, password: string) {
    loading.value = true
    try {
      await registerService(auth, email, password)
      addToast('Registration successful!', 'success')
      return router.push({ name: 'Dashboard' })
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    } finally {
      loading.value = false
    }
  }

  async function logout() {
    loading.value = true
    try {
      await logoutService(auth)
      addToast('You have been logged out.', 'info')
      return router.push({ name: 'Home' })
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    } finally {
      loading.value = false
    }
  }

  return { login, loginWithGoogle, register, logout, loading }
}


═══════════════════════════════════════════════
📄 FILE: ./src/composables/usePasswordReset.ts
───────────────────────────────────────────────
import { ref } from 'vue'
import { sendPasswordResetEmail } from 'firebase/auth'
import { auth } from '@/firebase/firebaseConfig'
import { addToast } from './useToast'
import type { FirebaseError } from 'firebase/app'

const firebaseMessages: Record<string, string> = {
  'auth/email-already-in-use': 'This email is already registered.',
  'auth/wrong-password': 'Incorrect password. Please try again.',
  'auth/user-not-found': 'No account found with that email.',
  // …etc
}

export function usePasswordReset() {
  const loading = ref(false)

  async function reset(email: string) {
    loading.value = true
    try {
      await sendPasswordResetEmail(auth, email)
      addToast('Check your inbox for reset instructions.', 'success')
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    } finally {
      loading.value = false
    }
  }

  return { reset, loading }
}


═══════════════════════════════════════════════
📄 FILE: ./src/composables/useToast.ts
───────────────────────────────────────────────
// src/composables/useToast.ts
import { ref } from 'vue'

export type Variant = 'info' | 'success' | 'warning' | 'error'

export interface ToastItem {
  id: number
  message: string
  variant: Variant
}

const toasts = ref<ToastItem[]>([])
let nextId = 1

export function addToast(
  message: string,
  variant: Variant = 'info',
  duration = 3000,
) {
  const id = nextId++
  toasts.value.push({ id, message, variant })
  setTimeout(() => removeToast(id), duration)
}

export function removeToast(id: number) {
  toasts.value = toasts.value.filter((t) => t.id !== id)
}

export function useToast() {
  return { toasts, addToast, removeToast }
}


═══════════════════════════════════════════════
📄 FILE: ./src/firebase/firebase.d.ts
───────────────────────────────────────────────
declare module '@/firebase/firebaseConfig' {
  import { Auth } from 'firebase/auth'
  export const auth: Auth
}


═══════════════════════════════════════════════
📄 FILE: ./src/firebase/firebaseConfig.ts
───────────────────────────────────────────────
// src/firebase/firebaseConfig.ts
import { initializeApp } from 'firebase/app'
import { getFirestore } from 'firebase/firestore'
import {
  getAuth,
  setPersistence,
  browserSessionPersistence,
  // You can still alias this if you need it for debugging:
} from 'firebase/auth'

// Use Vite's import.meta.env for environment variables
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
}

// Initialize Firebase
const app = initializeApp(firebaseConfig)

// Initialize Firebase services
const auth = getAuth(app)
const db = getFirestore(app)

// Optional: set persistence
setPersistence(auth, browserSessionPersistence)
  .then(() => {
    console.log('[FirebaseConfig] Persistence set')
  })
  .catch(console.error)

// Export exactly one auth instance
export { auth, db }


═══════════════════════════════════════════════
📄 FILE: ./src/hooks/useAuth.ts
───────────────────────────────────────────────
// src/hooks/useAuth.ts
import { useRouter } from 'vue-router'
import { auth } from '@/firebase/firebaseConfig'
import {
  login as loginService,
  loginWithGoogle as googleService,
  register as registerService,
  logout as logoutService,
} from '@/services/authServices'
import type { FirebaseError } from 'firebase/app'
import { addToast } from '@/composables/useToast'

const firebaseMessages: Record<string, string> = {
  'auth/email-already-in-use': 'This email is already registered.',
  'auth/wrong-password': 'Incorrect password. Please try again.',
  'auth/user-not-found': 'No account found with that email.',
  // …etc
}

export const useAuth = () => {
  const router = useRouter()

  const login = async (email: string, password: string) => {
    try {
      await loginService(auth, email, password)
      router.push({ name: 'Dashboard' }) // redirect after login
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    }
  }

  const loginWithGoogle = async () => {
    try {
      await googleService(auth)
      router.push({ name: 'Dashboard' })
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    }
  }

  const register = async (email: string, password: string) => {
    await registerService(auth, email, password)
    router.push({ name: 'Dashboard' })
  }

  const logout = async () => {
    try {
      await logoutService(auth)
      router.push({ name: 'Home' })
    } catch (err: unknown) {
      const msg =
        firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
      addToast(msg, 'error')
      throw err
    }
  }

  return { login, loginWithGoogle, register, logout }
}


═══════════════════════════════════════════════
📄 FILE: ./src/main.ts
───────────────────────────────────────────────
// src/main.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import '@/assets/tailwind.css'

const app = createApp(App)

// register Pinia before any store is used
app.use(createPinia())
app.use(router)

app.mount('#app')


═══════════════════════════════════════════════
📄 FILE: ./src/router/index.ts
───────────────────────────────────────────────
// src/router/index.ts
import {
  createRouter,
  createWebHistory,
  type RouteRecordRaw,
  // type NavigationGuardNext,
  // type RouteLocationNormalized,
} from 'vue-router'
import HomeView from '@/views/home/HomeView.vue'
import LoginView from '@/views/login/LoginView.vue'
import DashboardView from '@/views/dashboard/DashboardView.vue'
import AuthLayout from '@/layouts/auth/AuthLayout.vue'
import DefaultLayout from '@/layouts/default/DefaultLayout.vue'
import { useAuthStore } from '@/stores/authStore'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    component: DefaultLayout,
    children: [
      { path: '', name: 'Home', component: HomeView },
      { path: 'login', name: 'Login', component: LoginView },
      {
        path: 'register',
        name: 'Register',
        component: () => import('@/views/register/RegisterView.vue'),
      },
      {
        path: 'reset-password',
        name: 'ResetPassword',
        component: () => import('@/views/reset-password/ResetPasswordView.vue'),
      },
    ],
  },
  {
    path: '/dashboard',
    component: AuthLayout,
    meta: { requiresAuth: true },
    children: [
      { path: '', name: 'Dashboard', component: DashboardView },
      // Future protected routes can go here
    ],
  },
  { path: '/:pathMatch(.*)*', redirect: '/' },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

// --- Navigation Guard ---
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()
  const requiresAuth = to.matched.some((record) => record.meta?.requiresAuth)

  if (!authStore.initialized) {
    // Wait for auth to initialize before proceeding
    const unwatch = authStore.$subscribe(() => {
      if (authStore.initialized) {
        unwatch()
        proceed()
      }
    })
  } else {
    proceed()
  }

  function proceed() {
    if (requiresAuth && !authStore.isAuthenticated) {
      console.log('[AuthGuard] No authenticated user. Redirecting to Login...')
      next({ name: 'Login', query: { redirect: to.fullPath } })
    } else {
      next()
    }
  }
})

export default router


═══════════════════════════════════════════════
📄 FILE: ./src/services/authServices.cy.ts
───────────────────────────────────────────────
// src/services/authServices.cy.ts
import { login, logout, register, loginWithGoogle } from './authServices'
import sinon from 'sinon'
// Import the Auth type from firebase/auth if you use Partial<Auth>
// import type { Auth } from 'firebase/auth';
import type { FirebaseError } from 'firebase/app'
import { addToast } from '@/composables/useToast'

const firebaseMessages: Record<string, string> = {
  'auth/email-already-in-use': 'This email is already registered.',
  'auth/wrong-password': 'Incorrect password. Please try again.',
  'auth/user-not-found': 'No account found with that email.',
  // …etc
}

describe('Auth Service', () => {
  // Define a type for your mock Auth object.
  // No need for Partial<Auth> unless you're passing the mock to something
  // that expects a full Auth object, which your services don't currently.
  // Just defining the methods you stub is sufficient.
  interface MockAuth {
    signInWithEmailAndPassword: sinon.SinonStub
    signOut: sinon.SinonStub
    createUserWithEmailAndPassword: sinon.SinonStub
    signInWithPopup: sinon.SinonStub
    // Add any other Firebase Auth properties/methods your services might *use*
    // (even if not stubbed in this test, the service function might try to access them)
    // For example, if a service function used auth.currentUser, you'd add:
    // currentUser: any; // Or a more specific User | null type
  }

  let mockAuth: MockAuth

  beforeEach(() => {
    // Re-create the mock object before each test
    mockAuth = {
      signInWithEmailAndPassword: sinon.stub(),
      signOut: sinon.stub(),
      createUserWithEmailAndPassword: sinon.stub(),
      signInWithPopup: sinon.stub(),
      // If adding currentUser:
      // currentUser: null, // Or a mock user if needed
    }
  })

  describe('login function', () => {
    it('should handle login errors correctly', async () => {
      const errorMessage = 'Login failed'
      // Mocking with a standard Error instance
      mockAuth.signInWithEmailAndPassword.rejects(new Error(errorMessage))

      try {
        // Note: You are passing mockAuth.signInWithEmailAndPassword as the signInFn,
        // but the function signature expects a type compatible with typeof signInWithEmailAndPassword.
        // Sinon stubs are usually compatible enough.
        await login(
          mockAuth as any, // Type assertion might be needed if MockAuth is too strict
          'test@example.com',
          'wrongpassword',
          mockAuth.signInWithEmailAndPassword as any, // Type assertion here too
        )
        // If the promise *wasn't* rejected, the test should fail
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (err: unknown) {
        const msg =
          firebaseMessages[(err as FirebaseError).code] ??
          'Something went wrong'
        addToast(msg, 'error')
        throw err
      }
    })

    it('should return user on successful login', async () => {
      const mockUser = { uid: '12345', email: 'test@example.com' }
      // Mocking the resolved value structure { user: ... }
      mockAuth.signInWithEmailAndPassword.resolves({ user: mockUser })

      const result = await login(
        mockAuth as any, // Type assertion if needed
        'test@example.com',
        'correctpassword',
        mockAuth.signInWithEmailAndPassword as any, // Type assertion if needed
      )
      // Your login service returns credential.user, which matches mockUser
      expect(result).to.deep.equal(mockUser)
    })
  })

  describe('logout function', () => {
    it('should call signOut and complete successfully', async () => {
      mockAuth.signOut.resolves()

      await logout(mockAuth as any, mockAuth.signOut as any) // Type assertions if needed

      expect(mockAuth.signOut).to.have.been.calledOnce
    })

    it('should handle errors during logout', async () => {
      const errorMessage = 'Logout failed'
      mockAuth.signOut.rejects(new Error(errorMessage)) // Mocking with Error instance

      try {
        await logout(mockAuth as any, mockAuth.signOut as any) // Type assertions if needed
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (err: unknown) {
        const msg =
          firebaseMessages[(err as FirebaseError).code] ??
          'Something went wrong'
        addToast(msg, 'error')
        throw err
      }
    })
  })

  describe('register function', () => {
    it('should handle registration errors correctly', async () => {
      // Mocking with an object structure that mimics FirebaseError
      // Your register service catches this and re-throws a standard Error with a custom message
      mockAuth.createUserWithEmailAndPassword.rejects({
        code: 'auth/email-already-in-use',
        message: 'The email address is already in use.',
      })

      try {
        // The register function *under test* will throw an Error('This email is already registered.')
        await register(
          mockAuth as any,
          'existing-email@example.com',
          'password123',
          mockAuth.createUserWithEmailAndPassword as any,
        )
        throw new Error('Expected registration to fail')
      } catch (err: unknown) {
        const msg =
          firebaseMessages[(err as FirebaseError).code] ??
          'Something went wrong'
        addToast(msg, 'error')
        throw err
      }
    })

    it('should return user on successful registration', async () => {
      const mockUserCredential = {
        user: { email: 'new-user@example.com', uid: 'abc' },
      } // Add uid as user might have it
      mockAuth.createUserWithEmailAndPassword.resolves(mockUserCredential)

      const userCredential = await register(
        mockAuth as any, // Type assertion if needed
        'new-user@example.com',
        'password123',
        mockAuth.createUserWithEmailAndPassword as any, // Type assertion if needed
      )
      // Your register service returns the userCredential directly
      expect(userCredential).to.equal(mockUserCredential)
    })
  })

  describe('loginWithGoogle function', () => {
    it('should handle Google login errors correctly', async () => {
      const errorMessage = 'Google login failed'
      mockAuth.signInWithPopup.rejects(new Error(errorMessage)) // Mocking with Error instance

      try {
        // The loginWithGoogle function under test returns credential.user on success,
        // but throws the original error on failure.
        await loginWithGoogle(mockAuth as any, mockAuth.signInWithPopup as any) // Type assertions if needed
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (err: unknown) {
        const msg =
          firebaseMessages[(err as FirebaseError).code] ??
          'Something went wrong'
        addToast(msg, 'error')
        throw err
      }
    })

    it('should return user on successful Google login', async () => {
      const mockUser = { uid: '12345', email: 'test@example.com' }
      mockAuth.signInWithPopup.resolves({ user: mockUser }) // Mocking resolved value structure { user: ... }

      const result = await loginWithGoogle(
        mockAuth as any,
        mockAuth.signInWithPopup as any,
      ) // Type assertions if needed
      // Your loginWithGoogle service returns credential.user, which matches mockUser
      expect(result).to.deep.equal(mockUser)
    })
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/services/authServices.ts
───────────────────────────────────────────────
// src/services/authServices.ts
import type { Auth, UserCredential, User } from 'firebase/auth'
import {
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  signInWithPopup,
  GoogleAuthProvider,
} from 'firebase/auth'
import type { FirebaseError } from 'firebase/app'
import { addToast } from '@/composables/useToast'

const firebaseMessages: Record<string, string> = {
  'auth/email-already-in-use': 'This email is already registered.',
  'auth/wrong-password': 'Incorrect password. Please try again.',
  'auth/user-not-found': 'No account found with that email.',
  // …etc
}

/* ------------------------------ */
/*           login              */
/* ------------------------------ */
export const login = async (
  auth: Auth,
  email: string,
  password: string,
  signInFn: typeof signInWithEmailAndPassword = signInWithEmailAndPassword,
): Promise<UserCredential> => {
  return await signInFn(auth, email, password)
}

/* ------------------------------------------------------------------ */
/*  login with Google                                                 */
/* ------------------------------------------------------------------ */
export const loginWithGoogle = async (
  auth: Auth,
  // allow injection for testing; defaults to the real SDK fn
  popupFn: typeof signInWithPopup = signInWithPopup,
): Promise<User> => {
  const provider = new GoogleAuthProvider()
  const credential = await popupFn(auth, provider)
  return credential.user
}

/* ------------------------------------------------------------------ */
/*  logout                                                            */
/* ------------------------------------------------------------------ */
export const logout = async (
  auth: Auth,
  signOutFn: typeof signOut = signOut,
): Promise<void> => {
  await signOutFn(auth)
}

/* ------------------------------------------------------------------ */
/*  register                                                          */
/* ------------------------------------------------------------------ */
export const register = async (
  auth: Auth,
  email: string,
  password: string,
  createUserFn: typeof createUserWithEmailAndPassword = createUserWithEmailAndPassword,
): Promise<UserCredential> => {
  try {
    return await createUserFn(auth, email, password)
  } catch (err: unknown) {
    const msg =
      firebaseMessages[(err as FirebaseError).code] ?? 'Something went wrong'
    addToast(msg, 'error')
    throw err
  }
}


═══════════════════════════════════════════════
📄 FILE: ./src/services/firebaseMock.ts
───────────────────────────────────────────────
// src/services/firebaseAuthMock.js

import sinon from 'sinon'

export const mockAuth = {
  settings: {},
  signInWithEmailAndPassword: sinon.stub(),
  signOut: sinon.stub(),
  createUserWithEmailAndPassword: sinon.stub(),
  signInWithPopup: sinon.stub(),
}

export const resetAuthMocks = () => {
  mockAuth.signInWithEmailAndPassword.reset()
  mockAuth.signOut.reset()
  mockAuth.createUserWithEmailAndPassword.reset()
  mockAuth.signInWithPopup.reset()
}


═══════════════════════════════════════════════
📄 FILE: ./src/shim-vue.d.ts
───────────────────────────────────────────────
// src/shim-vue.d.ts
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-explicit-any
  const component: DefineComponent<{}, {}, any>
  export default component
}


═══════════════════════════════════════════════
📄 FILE: ./src/stores/authStore.ts
───────────────────────────────────────────────
// src/stores/authStore.ts
import { defineStore } from 'pinia'
import { auth } from '@/firebase/firebaseConfig'
import { onAuthStateChanged, type User } from 'firebase/auth'
import { ref, computed } from 'vue'

export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const initialized = ref(false)
  onAuthStateChanged(auth, (u) => {
    user.value = u
    initialized.value = true
  })
  const isAuthenticated = computed(() => !!user.value)
  return { user, isAuthenticated, initialized }
})


═══════════════════════════════════════════════
📄 FILE: ./tailwind.config.js
───────────────────────────────────────────────
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx,vue}'],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#1f2937',
          hover: '#111827',
          light: '#374151',
          dark: '#0f172a',
        },
        secondary: {
          DEFAULT: '#64748b',
          light: '#94a3b8',
          dark: '#475569',
        },
        accent: {
          DEFAULT: '#ff9f1c',
          light: '#ffb347',
          dark: '#cc7a00',
        },
        success: {
          DEFAULT: '#22c55e',
          light: '#4ade80',
          dark: '#15803d',
        },
        error: {
          DEFAULT: '#ef4444',
          light: '#f87171',
          dark: '#b91c1c',
        },
        warning: {
          DEFAULT: '#facc15',
          light: '#fde047',
          dark: '#ca8a04',
        },
        info: {
          DEFAULT: '#0ea5e9',
          light: '#38bdf8',
          dark: '#0369a1',
        },
        background: {
          DEFAULT: '#f8fafc',
          dark: '#1e293b',
        },
        surface: {
          DEFAULT: '#ffffff',
          dark: '#111827',
        },
        border: {
          DEFAULT: '#e2e8f0',
          dark: '#334155',
        },
        text: {
          primary: '#1e293b',
          secondary: '#64748b',
          tertiary: '#718096',
          inverted: '#ffffff',
        },
        muted: '#f1f5f9',
      },
      spacing: {
        xs: '0.25rem',
        sm: '0.5rem',
        md: '1rem',
        lg: '1.5rem',
        xl: '2rem',
      },
      borderRadius: {
        sm: '0.375rem',
        md: '0.5rem',
        lg: '1rem',
        xl: '1.5rem',
      },
      boxShadow: {
        sm: '0 1px 3px rgba(0, 0, 0, 0.12)',
        md: '0 4px 6px rgba(0, 0, 0, 0.1)',
        lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
        xl: '0 15px 25px rgba(0, 0, 0, 0.15)',
      },
      transitionDuration: {
        fast: '150ms',
        normal: '250ms',
        slow: '400ms',
      },
      transitionTimingFunction: {
        ease: 'ease',
        'ease-in': 'ease-in',
        'ease-out': 'ease-out',
      },
      container: {
        center: true,
        padding: {
          DEFAULT: '1rem',
          sm: '1rem',
          lg: '2rem',
          xl: '2rem',
        },
      },
    },
  },
  plugins: [],
}


