═══════════════════════════════════════════════
📄 FILE: ./eslint.config.js
───────────────────────────────────────────────
// eslint.config.js
import { defineConfig } from 'eslint/config'
import js from '@eslint/js'
import pluginVue from 'eslint-plugin-vue'
import tsESLint from '@typescript-eslint/eslint-plugin'
import tsParser from '@typescript-eslint/parser'
import vueParser from 'vue-eslint-parser'
import pluginPrettier from 'eslint-plugin-prettier'
import cypressPlugin from 'eslint-plugin-cypress'
import tailwindCustomPlugin from './scripts/eslint-plugin-tailwind-custom-colors.cjs'

export default defineConfig([
  // --- Main config for JS, TS, and Vue files ---
  {
    // Target the primary source files
    files: ['**/*.{js,ts,vue}'],

    // Ignores apply to this specific config object's file pattern.
    // They also help ESLint's overall ignore behavior.
    ignores: [
      'node_modules/**',
      'dist/**',
      // Keep existing ignores for config/script files from this block
      '*.config.js',
      '*.config.ts',
      'scripts/**',
      'check-pnpm.js',
      // Explicitly ignore test files from *this* block, handled in their own block
      'cypress/**',
      'src/**/*.cy.{js,ts}',
    ],

    plugins: {
      '@typescript-eslint': tsESLint,
      vue: pluginVue,
      prettier: pluginPrettier,
      // Remove cypress plugin from here, apply only in test block
      // cypress: cypressPlugin,
      'tailwind-custom-colors': tailwindCustomPlugin,
    },

    languageOptions: {
      // Use vue-eslint-parser for this block covering .vue files
      // It will handle passing TS files to tsParser.
      parser: vueParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        // Tell vue-eslint-parser to use tsParser for the <script> block
        parser: tsParser,
        extraFileExtensions: ['.vue'],
        // project: ['./tsconfig.json'], // Add if TS rules need type info
        // tsconfigRootDir: __dirname, // Add if TS rules need type info
      },
      globals: {
        console: 'readonly', // Console is available in most environments
      },
    },

    settings: {
      // Remove cypress settings from here
      // ...cypressPlugin.configs.recommended.settings,
    },

    rules: {
      ...js.configs.recommended.rules, // Base JS rules
      ...pluginVue.configs['flat/recommended'].rules, // Vue recommended rules (applied to .vue files)
      ...tsESLint.configs.recommended.rules, // Base TS rules (applied via tsParser)

      // Customize unused vars rule - allow leading underscore for args/caught errors
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_', caughtErrorsIgnorePattern: '^_' },
      ],
      'prettier/prettier': 'error', // Prettier integration rule
      'tailwind-custom-colors/no-non-theme-tailwind-colors': 'warn', // Custom plugin rule

      // The no-console rule allows specific console methods
      'no-console': ['warn', { allow: ['warn', 'error', 'log'] }],

      // Disable no-undef as we are explicitly defining globals where needed
      // and relying on TS for other undefined checks in TS files.
      'no-undef': 'off',
    },
  },

  // --- Special config for Cypress & Test files (js, ts) ---
  // These files were ignored in the first block, now configured specifically.
  {
    files: [
      'cypress/**/*.{js,ts}', // Cypress specific files
      'src/**/*.cy.{js,ts}', // Component/service test files
    ],
    // No ignores needed here, files pattern is specific.
    plugins: {
      '@typescript-eslint': tsESLint, // Needed for TS test files
      cypress: cypressPlugin, // Needed for Cypress rules and globals
    },
    languageOptions: {
      // Use tsParser for TS test files (and works for JS test files)
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        // project: ['./tsconfig.json'], // Add if TS rules in tests need type info
        // tsconfigRootDir: __dirname, // Add if TS rules in tests need type info
      },
      globals: {
        // Declare Cypress, Mocha, Chai, Sinon, and other test globals explicitly
        Cypress: 'readonly',
        cy: 'readonly',
        describe: 'readonly', // Mocha global
        it: 'readonly', // Mocha global
        expect: 'readonly', // Chai global (used by Cypress/Mocha)
        assert: 'readonly', // Chai global
        before: 'readonly', // Mocha global
        after: 'readonly', // Mocha global
        beforeEach: 'readonly', // Mocha global
        afterEach: 'readonly', // Mocha global
        sinon: 'readonly', // Sinon global (seen in authServices.cy.js)
        MouseEvent: 'readonly', // Standard DOM global used in BaseButton.cy.ts
        console: 'readonly', // Console is also used in tests
      },
    },
    settings: {
      // Apply cypress recommended settings here for globals etc.
      ...cypressPlugin.configs.recommended.settings,
    },
    rules: {
      // Apply Cypress recommended rules
      ...cypressPlugin.configs.recommended.rules,

      // Disable the no-undef rule for test files as we define globals above
      'no-undef': 'off',

      // Disable @typescript-eslint/no-unused-expressions in test files
      // This rule commonly flags 'expect(...)' assertions.
      '@typescript-eslint/no-unused-expressions': 'off',

      // You might want different unused var rules in tests (e.g., warn instead of error)
      // '@typescript-eslint/no-unused-vars': 'warn', // Example: Change to warn
    },
  },

  // --- Config for JS config/script files ---
  // These files were ignored in the first block, now configured specifically.
  {
    files: ['*.config.js', '*.config.ts', 'scripts/**/*.js', 'check-pnpm.js'],
    // No ignores needed here, files pattern is specific.
    plugins: {
      prettier: pluginPrettier, // If you want prettier in config files
    },
    languageOptions: {
      // Explicitly *do not* use tsParser for these files, as they are plain JS or config TS
      // Let ESLint default parser handle them or use espree implicitly.
      parser: undefined, // Or parser: null
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module', // Use module syntax for modern config files
      },
      globals: {
        // Add Node.js globals typically available in config/script files
        __dirname: 'readonly',
        process: 'readonly',
        module: 'readonly',
        require: 'readonly',
        console: 'readonly',
      },
    },
    rules: {
      ...js.configs.recommended.rules, // Apply base JS rules
      'prettier/prettier': 'error', // Apply Prettier rule

      // Disable TS rules and no-undef as they don't apply here
      '@typescript-eslint/no-unused-vars': 'off',
      'no-undef': 'off', // Disable no-undef as Node globals might not be covered by base js config
    },
  },

  // --- Specific config to handle/ignore .d.ts files ---
  // This is a fallback block. If .d.ts files somehow aren't fully ignored
  // by the 'ignores' in the first block and cause parsing errors, this block
  // explicitly targets them and prevents any parser from running.
  // --- Specific config to handle/ignore .d.ts files ---
  // --- Specific config to handle/ignore .d.ts files ---
  {
    files: ['vite-env.d.ts', '**/*.d.ts'],
    languageOptions: {
      parser: undefined, // Or parser: null
    },
    rules: {
      // Turn off all potentially conflicting rules for these files.
      // Since no parser runs, most rules won't apply anyway, but this is safer.
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off', // .d.ts files can have types only used locally
      'no-undef': 'off',
      'prettier/prettier': 'off', // Ensure prettier doesn't try to format them
      // You could add 'off' for other specific plugin rules if necessary
    }, // <--- This brace closes the 'rules' object. GOOD.


═══════════════════════════════════════════════
📄 FILE: ./src/assets/tailwind.css
───────────────────────────────────────────────
@tailwind base;
@tailwind components;
@tailwind utilities;


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseAlert/BaseAlert.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseAlert/BaseAlert.cy.ts
import { mount } from '@cypress/vue'
import BaseAlert from './BaseAlert.vue' // Assuming BaseAlert.vue is the component file

// Define the possible variant types for better type safety (Optional but recommended)
type AlertVariant = 'info' | 'success' | 'warning' | 'danger'

describe('BaseAlert Component', () => {
  it('renders correctly with info variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'info' as AlertVariant, // Type assertion for clarity
      },
      slots: {
        default: 'Info alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-info-light')
      .and('have.class', 'text-info-dark')
  })

  it('renders correctly with success variant', () => {
    // Note: There might be a typo in your original JS test: 'text-info-darkabg-success-light'
    // Assuming it should be 'bg-success-light'
    mount(BaseAlert, {
      props: {
        variant: 'success' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Success alert',
      },
    })
    cy.get('[role="alert"]')
      // Corrected class name based on assumption
      .should('have.class', 'bg-success-light')
      .and('have.class', 'text-success-dark')
  })

  it('renders correctly with warning variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'warning' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Warning alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-warning-light')
      .and('have.class', 'text-warning-dark')
  })

  it('renders correctly with danger variant', () => {
    mount(BaseAlert, {
      props: {
        variant: 'danger' as AlertVariant, // Type assertion
      },
      slots: {
        default: 'Danger alert',
      },
    })
    cy.get('[role="alert"]')
      .should('have.class', 'bg-error-light')
      .and('have.class', 'text-error-dark')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseButton/BaseButton.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseButton/BaseButton.cy.ts
import { mount } from '@cypress/vue'
import BaseButton from './BaseButton.vue' // Ensure this path is correct
import type { DefineComponent } from 'vue'

// Define the possible variant types for better type safety
type ButtonVariant = 'primary' | 'secondary' | 'primaryOutlined'

// Define the props structure for type checking when creating the props object
// (We won't use this as a generic for mount anymore)
interface BaseButtonProps {
  variant?: ButtonVariant
  loading?: boolean
  disabled?: boolean // Added based on your component code
  class?: string | string[] | Record<string, boolean> // Added based on your component code
  // Add any other specific event handlers if needed, e.g., onClick?: (event: MouseEvent) => void;
}

describe('BaseButton Component', () => {
  // Helper function to type the props object (Optional but can help)
  const createProps = (props: BaseButtonProps) => props

  it('renders correctly with primary variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primary' }),
      slots: {
        default: 'Primary Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-primary')
      .and('have.class', 'text-white')
      .and('not.have.class', 'opacity-50') // Check it's not disabled/loading
      .and('not.have.class', 'opacity-70')
  })

  it('renders correctly with secondary variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'secondary' }),
      slots: {
        default: 'Secondary Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-secondary')
      .and('have.class', 'text-white')
      .and('not.have.class', 'opacity-50')
      .and('not.have.class', 'opacity-70')
  })

  it('renders correctly with primaryOutlined variant', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primaryOutlined' }),
      slots: {
        default: 'Outlined Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'border')
      .and('have.class', 'text-primary')
      .and('have.class', 'bg-white') // Check other expected classes
      .and('not.have.class', 'opacity-50')
      .and('not.have.class', 'opacity-70')
  })

  it('displays spinner and correct classes when loading is true', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: true, variant: 'primary' }),
      slots: {
        default: 'Primary Button', // Slot content exists even if hidden
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'opacity-70')
      .and('have.class', 'cursor-wait') // Check cursor class from your component
      .and('be.disabled') // Check disabled attribute

    cy.get('[data-cy="button"] svg.animate-spin').should('exist')
    // The span with slot content might still be in the DOM but hidden,
    // depending on how v-if/v-show is used. If it's truly removed by v-if:
    // cy.get('[data-cy="button"] span').should('not.exist');
    // If it's hidden (e.g., display: none), check visibility:
    cy.get('[data-cy="button"] > span').should('not.be.visible') // Check direct child span specifically

    // Verify spinner has text-white class (or adapt based on variant)
    cy.get('[data-cy="button"] svg.animate-spin').should(
      'have.class',
      'text-white',
    )
  })

  it('applies disabled classes and attribute when disabled is true', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ disabled: true, variant: 'primary' }),
      slots: {
        default: 'Disabled Button',
      },
    })
    cy.get('[data-cy="button"]')
      .should('have.class', 'opacity-50')
      .and('have.class', 'cursor-not-allowed')
      .and('be.disabled') // Check the disabled attribute

    // Ensure spinner is NOT shown
    cy.get('[data-cy="button"] svg.animate-spin').should('not.exist')
    cy.get('[data-cy="button"] > span').should('be.visible')
  })

  it('emits click event when clicked and not loading/disabled', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: false, disabled: false }),
      slots: {
        default: 'Clickable Button',
      },
    }).then(({ wrapper }) => {
      cy.get('[data-cy="button"]').click()
      cy.get('[data-cy="button"]').then(() => {
        const emittedEvents = wrapper.emitted('click')
        expect(emittedEvents).to.exist
        expect(emittedEvents).to.have.length(1)
        // Check payload is an array containing the original MouseEvent
        expect(emittedEvents?.[0]?.[0]).to.be.instanceOf(MouseEvent)
      })
    })
  })

  it('does NOT emit click event when loading', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ loading: true }),
      slots: { default: 'Loading' },
    }).then(({ wrapper }) => {
      // Use { force: true } because Cypress won't click disabled elements by default
      cy.get('[data-cy="button"]').click({ force: true })

      cy.get('[data-cy="button"]').then(() => {
        expect(wrapper.emitted('click')).to.not.exist
      })
    })
  })

  it('does NOT emit click event when disabled', () => {
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ disabled: true }),
      slots: { default: 'Disabled' },
    }).then(({ wrapper }) => {
      // Use { force: true } because Cypress won't click disabled elements by default
      cy.get('[data-cy="button"]').click({ force: true })

      cy.get('[data-cy="button"]').then(() => {
        expect(wrapper.emitted('click')).to.not.exist
      })
    })
  })

  it('merges passed classes correctly', () => {
    const extraClass = 'my-extra-class'
    mount(BaseButton, {
      // <-- Removed <BaseButtonProps> generic
      props: createProps({ variant: 'primary', class: extraClass }),
      slots: { default: 'Extra Class Button' },
    })

    cy.get('[data-cy="button"]')
      .should('have.class', 'bg-primary') // Check base variant class
      .and('have.class', extraClass) // Check merged class
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseCard/BaseCard.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseCard/BaseCard.cy.ts

import { mount } from '@cypress/vue'
import BaseCard from './BaseCard.vue' // Import the Vue component

describe('BaseCard Component', () => {
  it('renders card content correctly with expected styles', () => {
    const slotContent = '<p>This is the card content</p>' // Define slot content

    // Mount the component, passing the slot content
    mount(BaseCard, {
      slots: {
        default: slotContent, // Use the defined variable
      },
    })

    // Select the component's root element (assuming it's the div)
    // Chain the class assertions for better readability
    cy.get('div.bg-white.shadow-md.rounded.p-6') // More specific selector
      .should('exist') // Make sure the element itself exists with these classes
      .and('have.class', 'bg-white')
      .and('have.class', 'shadow-md')
      .and('have.class', 'rounded')
      .and('have.class', 'p-6')
      // Check the content *within* this div
      .find('p') // Find the paragraph element within the card
      .should('have.text', 'This is the card content') // Use have.text for exact match

    /* Alternative approach: Add a data-cy attribute for robustness */
    /*
    // In BaseCard.vue: <div data-cy="base-card" class="bg-white ...">
    mount(BaseCard, {
        slots: { default: slotContent }
    });

    cy.get('[data-cy="base-card"]')
        .should('have.class', 'bg-white')
        .and('have.class', 'shadow-md')
        .and('have.class', 'rounded')
        .and('have.class', 'p-6')
        .find('p')
        .should('have.text', 'This is the card content');
    */
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseInput/BaseInput.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseInput/BaseInput.cy.ts

import { mount } from '@cypress/vue'
import BaseInput from './BaseInput.vue'

describe('BaseInput Component', () => {
  // Define base props that are required by the component's type definition
  // Assuming 'type' and 'disabled' are the required ones based on the error
  const requiredBaseProps = {
    type: 'text', // Provide a default type if required
    disabled: false, // Provide a default disabled state if required
    modelValue: '', // Include modelValue with a default empty string
  }

  it('renders input with the correct type and placeholder', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Start with the required base props
        type: 'text', // Override type for this specific test
        placeholder: 'Enter your name',
        // disabled: false, // Already included in requiredBaseProps default
      },
    })
    cy.get('input').should('have.attr', 'type', 'text')
    cy.get('input').should('have.attr', 'placeholder', 'Enter your name')
    cy.get('input').should('not.be.disabled') // Also good to assert the default disabled state
  })

  it('emits the correct value on input', () => {
    const onUpdateSpy = cy.spy().as('onUpdateSpy')

    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        modelValue: '', // This test focuses on modelValue, explicitly setting it
        'onUpdate:modelValue': onUpdateSpy,
        // type: 'text', // Already included in requiredBaseProps default
        // disabled: false, // Already included in requiredBaseProps default
      },
    })

    cy.get('input').type('Hello World')

    cy.get('@onUpdateSpy').should('have.been.calledOnceWith', 'Hello World')
  })

  it('applies correct classes for disabled state', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        disabled: true, // Override disabled for this specific test
        // type: 'text', // Already included in requiredBaseProps default
        // modelValue: '', // Already included in requiredBaseProps default
      },
    })
    cy.get('input').should('have.class', 'opacity-50')
    cy.get('input').should('have.class', 'cursor-not-allowed')
    cy.get('input').should('be.disabled')
  })

  it('applies correct classes for password type', () => {
    mount(BaseInput, {
      props: {
        ...requiredBaseProps, // Include required base props
        type: 'password', // Override type for this specific test
        // disabled: false, // Already included in requiredBaseProps default
        // modelValue: '', // Already included in requiredBaseProps default
      },
    })
    // Note: Double-check if border-error-light/focus:ring-error-light
    // is *only* for password type or password type with an error.
    // Assuming it's just for password type based on the original test comment.
    cy.get('input').should('have.class', 'border-error-light')
    cy.get('input').should('have.class', 'focus:ring-error-light')
    cy.get('input').should('have.attr', 'type', 'password') // Assert type is set
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseLink/BaseLink.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseLink/BaseLink.cy.ts

import { mount } from '@cypress/vue'
import { createRouter, createWebHistory } from 'vue-router'
import BaseLink from './BaseLink.vue'

// Setup routes for testing the router-link component
const routes = [
  { path: '/', component: { template: '<div>Home Page</div>' } },
  { path: '/about', component: { template: '<div>About Page</div>' } },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

describe('BaseLink Component', () => {
  it('renders with the correct `to` attribute', () => {
    mount(BaseLink, {
      global: {
        plugins: [router],
      },
      props: {
        to: '/about',
      },
      slots: {
        default: 'Go to About',
      },
    })

    cy.get('a').should('have.attr', 'href', '/about')
    cy.get('a').should('contain.text', 'Go to About')
  })

  it('navigates correctly when clicked', () => {
    mount(BaseLink, {
      global: {
        plugins: [router],
      },
      props: {
        to: '/about',
      },
      slots: {
        default: 'Go to About',
      },
    })

    cy.get('a').click()
    cy.url().should('include', '/about')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseLoading/BaseLoading.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseLoading/BaseLoading.cy.ts

import { mount } from '@cypress/vue'
import BaseLoading from './BaseLoading.vue'

describe('BaseLoading Component', () => {
  it('renders the loading spinner', () => {
    mount(BaseLoading)

    // Check if the loader div is present
    cy.get('.loader')
      .should('exist')
      .and('have.class', 'ease-linear')
      .and('have.class', 'rounded-full')
      .and('have.class', 'border-8')
  })

  it('has the correct fixed position and overlay', () => {
    mount(BaseLoading)

    // Make sure we're targeting the outer overlay div with the 'fixed' class
    cy.get('div.fixed')
      .should('have.class', 'inset-0')
      .and('have.class', 'bg-black')
      .and('have.class', 'bg-opacity-50')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/BaseModal/BaseModal.cy.ts
───────────────────────────────────────────────
// src/components/atoms/BaseModal.cy.ts

import { mount } from '@cypress/vue'
import BaseModal from './BaseModal.vue'

describe('BaseModal Component', () => {
  it('renders the modal when visible is true', () => {
    mount(BaseModal, {
      props: {
        visible: true,
      },
    })

    // Assert the modal is rendered
    cy.get('div.fixed')
      .should('have.class', 'inset-0')
      .and('have.class', 'bg-black')
      .and('have.class', 'bg-opacity-50')

    cy.get('div.bg-white')
      .should('exist')
      .and('have.class', 'p-6')
      .and('have.class', 'rounded')
  })

  it('emits the close event when close button is clicked', () => {
    // Mount the component and pass a function as a prop to listen for 'close' event
    const onCloseSpy = cy.spy().as('onCloseSpy')

    mount(BaseModal, {
      props: {
        visible: true,
        onClose: onCloseSpy, // Attach the spy function to the close event
      },
    })

    // Click on the close button
    cy.get('button').contains('X').click()

    // Check if the event 'close' was called
    cy.get('@onCloseSpy').should('have.been.calledOnce')
  })

  it('does not render the modal when visible is false', () => {
    mount(BaseModal, {
      props: {
        visible: false,
      },
    })

    // Assert that the modal does not exist
    cy.get('div.fixed').should('not.exist')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/atoms/index.ts
───────────────────────────────────────────────
export { default as BaseAlert } from './BaseAlert/BaseAlert.vue'
export { default as BaseButton } from './BaseButton/BaseButton.vue'
export { default as BaseCard } from './BaseCard/BaseCard.vue'
export { default as BaseInput } from './BaseInput/BaseInput.vue'
export { default as BaseLink } from './BaseLink/BaseLink.vue'
export { default as BaseLoading } from './BaseLoading/BaseLoading.vue'
export { default as BaseModal } from './BaseModal/BaseModal.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/components/index.ts
───────────────────────────────────────────────
export * from './atoms'
export * from './molecules'
export * from './organisms'


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/BaseNavigation/BaseNavigation.cy.ts
───────────────────────────────────────────────
import { mount } from '@cypress/vue'
import BaseNavigation from './BaseNavigation.vue'
import { createMemoryHistory, createRouter } from 'vue-router'
import BaseLink from '@/components/atoms/BaseLink/BaseLink.vue'

// Define the routes
const routes = [
  { path: '/dashboard', component: { template: '<div>Dashboard Page</div>' } },
]
const router = createRouter({
  history: createMemoryHistory(),
  routes,
})

describe('BaseNavigation Component', () => {
  it('renders the Dashboard link when authenticated', () => {
    mount(BaseNavigation, {
      props: {
        isAuthenticated: true,
      },
      global: {
        plugins: [router],
        components: {
          Link: BaseLink, // Register BaseLink as a global component
        },
      },
    })

    // Ensure the dashboard link is visible
    cy.get('a').should('contain.text', 'Dashboard')
    cy.get('a').should('have.attr', 'href', '/dashboard')
  })

  it('does not render the Dashboard link when not authenticated', () => {
    mount(BaseNavigation, {
      props: {
        isAuthenticated: false,
      },
      global: {
        plugins: [router],
        components: {
          Link: BaseLink,
        },
      },
    })

    // Ensure the dashboard link is not visible
    cy.get('a').should('not.exist')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/FormField/FormField.cy.ts
───────────────────────────────────────────────
import { mount } from '@cypress/vue'
import FormField from './FormField.vue'
import BaseInput from '@/components/atoms/BaseInput/BaseInput.vue'

describe('FormField Component', () => {
  it('renders the label and input correctly', () => {
    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Test Label',
        modelValue: '',
        placeholder: 'Enter text',
      },
      global: {
        components: { BaseInput },
      },
    })

    // Check that the label and input are rendered correctly
    cy.get('label').should('have.text', 'Test Label')
    cy.get('input')
      .should('have.attr', 'placeholder', 'Enter text')
      .should('have.attr', 'id', 'test-input')
  })

  it('updates the value when typing', () => {
    const onUpdateSpy = cy.spy().as('onUpdateSpy')

    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Test Label',
        modelValue: '',
        placeholder: 'Enter text',
        'onUpdate:modelValue': onUpdateSpy,
      },
      global: {
        components: { BaseInput },
      },
    })

    cy.get('input').type('Hello World')
    cy.get('@onUpdateSpy').should('have.been.calledWith', 'Hello World')
  })

  it('handles disabled state correctly', () => {
    mount(FormField, {
      props: {
        id: 'test-input',
        label: 'Disabled Input',
        modelValue: '',
        disabled: true,
      },
      global: {
        components: { BaseInput },
      },
    })

    cy.get('input').should('be.disabled')
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/components/molecules/index.ts
───────────────────────────────────────────────
export { default as AuthButton } from './AuthButton/AuthButton.vue'
export { default as BaseNavigation } from './BaseNavigation/BaseNavigation.vue'
export { default as FormField } from './FormField/FormField.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/components/organisms/index.ts
───────────────────────────────────────────────
// src/components/organisms/index.js
export { default as BaseHeader } from './BaseHeader/BaseHeader.vue'


═══════════════════════════════════════════════
📄 FILE: ./src/composables/useAuth.ts
───────────────────────────────────────────────
import { auth } from '@/firebase/firebaseConfig'
import {
  login as loginService,
  logout as logoutService,
  register as registerService,
  // loginWithGoogle is not directly used from authServices here,
  // as the original useAuth.js called the Firebase SDK directly for it.
} from '@/services/authServices'
import type { User, UserCredential } from 'firebase/auth'
import { signInWithPopup, GoogleAuthProvider } from 'firebase/auth' // Import necessary functions/providers for Google Login
import type { FirebaseError } from 'firebase/app'

// Define the shape of the user data returned by login functions
interface AuthUser {
  userName: string | null
  email: string | null
}

export const useAuth = () => {
  // General login function for email/password
  const login = async (email: string, password: string): Promise<AuthUser> => {
    try {
      // loginService is typed to return UserCredential in authServices.ts [cite: 56, 57]
      const userCredential: UserCredential = await loginService(
        auth,
        email,
        password,
      )
      const user: User = userCredential.user
      console.log('User logged in:', {
        userName: user.displayName,
        email: user.email,
      })
      // Return the defined AuthUser shape
      return { userName: user.displayName, email: user.email }
    } catch (error: unknown) {
      // Use type assertion for better error handling
      const firebaseError = error as FirebaseError
      console.error('Login failed:', firebaseError.message)
      throw firebaseError // Re-throw the original typed error
    }
  }

  // Specific login function using signInWithPopup for Google
  const loginWithGoogle = async (): Promise<AuthUser> => {
    const provider = new GoogleAuthProvider() // Standard way to instantiate Google Provider
    try {
      // Use the actual signInWithPopup function from Firebase Auth SDK
      const userCredential: UserCredential = await signInWithPopup(
        auth,
        provider,
      )
      const user: User = userCredential.user
      console.log('User logged in with Google:', {
        userName: user.displayName,
        email: user.email,
      })
      // Return the defined AuthUser shape
      return { userName: user.displayName, email: user.email }
    } catch (error: unknown) {
      const firebaseError = error as FirebaseError
      console.error('Google login failed:', firebaseError.message)
      throw firebaseError // Re-throw the original typed error
    }
  }

  // Register function
  const register = async (email: string, password: string): Promise<User> => {
    try {
      // registerService is typed to return UserCredential in authServices.ts [cite: 58, 59]
      const userCredential: UserCredential = await registerService(
        auth,
        email,
        password,
      )
      console.log('User registered:', userCredential.user.email)
      return userCredential.user // Return the User object as before
    } catch (error: unknown) {
      // Error handling logic from authServices.ts already provides a useful message [cite: 60]
      // Log the message here, but re-throw the original error for consistency
      console.error('Registration failed:', (error as Error).message)
      throw error
    }
  }

  // Logout function
  const logout = async (): Promise<void> => {
    try {
      // logoutService is typed in authServices.ts [cite: 57]
      await logoutService(auth)
      console.log('User logged out')
    } catch (error: unknown) {
      const firebaseError = error as FirebaseError
      console.error('Logout failed:', firebaseError.message)
      throw firebaseError // Re-throw the original typed error
    }
  }

  // Return the typed functions
  return { login, loginWithGoogle, register, logout }
}


═══════════════════════════════════════════════
📄 FILE: ./src/firebase/firebase.d.ts
───────────────────────────────────────────────
declare module '@/firebase/firebaseConfig' {
  import { Auth } from 'firebase/auth'
  export const auth: Auth
}


═══════════════════════════════════════════════
📄 FILE: ./src/firebase/firebaseConfig.ts
───────────────────────────────────────────────
// src/firebase/firebaseConfig.ts
import { initializeApp } from 'firebase/app'
import { getFirestore } from 'firebase/firestore'
import {
  getAuth,
  setPersistence,
  browserSessionPersistence,
  // You can still alias this if you need it for debugging:
} from 'firebase/auth'

// Use Vite's import.meta.env for environment variables
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
}

// Initialize Firebase
const app = initializeApp(firebaseConfig)

// Initialize Firebase services
const auth = getAuth(app)
const db = getFirestore(app)

// Optional: set persistence
setPersistence(auth, browserSessionPersistence)
  .then(() => {
    console.log('[FirebaseConfig] Persistence set')
  })
  .catch(console.error)

// Export exactly one auth instance
export { auth, db }


═══════════════════════════════════════════════
📄 FILE: ./src/main.ts
───────────────────────────────────────────────
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import '@/assets/tailwind.css'

createApp(App).use(router).mount('#app')


═══════════════════════════════════════════════
📄 FILE: ./src/router/index.ts
───────────────────────────────────────────────
// src/router/index.ts
import {
  createRouter,
  createWebHistory,
  type RouteRecordRaw,
  type NavigationGuardNext,
  type RouteLocationNormalized,
} from 'vue-router'
import type { User } from 'firebase/auth'
import HomeView from '@/views/Home/HomeView.vue'
import Login from '@/views/Login/LoginView.vue'
import Dashboard from '@/views/Dashboard/DashboardView.vue'
import AuthLayout from '@/layouts/auth/AuthLayout.vue'
import DefaultLayout from '@/layouts/default/DefaultLayout.vue'
import { auth } from '@/firebase/firebaseConfig'
import { onAuthStateChanged } from 'firebase/auth'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    component: DefaultLayout,
    children: [
      { path: '', name: 'Home', component: HomeView },
      { path: 'login', name: 'Login', component: Login },
      {
        path: 'register',
        name: 'Register',
        component: () => import('@/views/Register/RegisterView.vue'),
      },
      {
        path: 'reset-password',
        name: 'ResetPassword',
        component: () => import('@/views/reset-password/ResetPasswordView.vue'),
      },
    ],
  },
  {
    path: '/dashboard',
    component: AuthLayout,
    meta: { requiresAuth: true },
    children: [
      { path: '', name: 'Dashboard', component: Dashboard },
      // Add other authenticated routes here
    ],
  },
  { path: '/:pathMatch(.*)*', redirect: '/' },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

// 👇 Explicitly typed cleanup function
let unsubscribeAuth: (() => void) | null = null
let isAuthInitialized = false

// --- Helper function to check auth and decide navigation ---
function checkAuthAndNavigate(
  to: RouteLocationNormalized,
  requiresAuth: boolean,
  user: User | null,
  next: NavigationGuardNext,
) {
  const isDevelopment = import.meta.env.DEV

  if (requiresAuth && !user) {
    if (isDevelopment) {
      console.warn(
        `%c[AuthGuard] DEV MODE: Bypassing auth check for "${to.path}".`,
        'color: orange;',
      )
      next()
    } else {
      console.log(
        `[AuthGuard] Redirecting to Login. Route "${to.path}" requires auth.`,
      )
      next({ name: 'Login', query: { redirect: to.fullPath } })
    }
  } else {
    next()
  }
}

// --- Navigation Guard ---
router.beforeEach((to, from, next) => {
  const requiresAuth = to.matched.some((record) => record.meta?.requiresAuth)

  if (!isAuthInitialized) {
    if (!unsubscribeAuth) {
      unsubscribeAuth = onAuthStateChanged(
        auth,
        (user) => {
          isAuthInitialized = true
          console.log(
            `%c[AuthGuard] Initial state determined. User: ${
              user ? user.email : 'Not Logged In'
            }`,
            user ? 'color: green;' : 'color: red;',
          )
          checkAuthAndNavigate(to, requiresAuth, user, next)
        },
        (error) => {
          console.error('[AuthGuard] Error getting initial auth state:', error)
          isAuthInitialized = true
          console.log(
            `%c[AuthGuard] Initial state determined (error). User: Not Logged In`,
            'color: red;',
          )
          checkAuthAndNavigate(to, requiresAuth, null, next)
        },
      )
    }
    // Wait for onAuthStateChanged to call next()
  } else {
    const user = auth.currentUser
    console.log(
      `%c[AuthGuard] Navigating. Current User: ${
        user ? user.email : 'Not Logged In'
      }`,
      user ? 'color: green;' : 'color: red;',
    )
    checkAuthAndNavigate(to, requiresAuth, user, next)
  }
})

export default router


═══════════════════════════════════════════════
📄 FILE: ./src/services/authServices.cy.ts
───────────────────────────────────────────────
// src/services/authServices.cy.ts
import { login, logout, register, loginWithGoogle } from './authServices'
import sinon from 'sinon'
// Import the Auth type from firebase/auth if you use Partial<Auth>
// import type { Auth } from 'firebase/auth';

describe('Auth Service', () => {
  // Define a type for your mock Auth object.
  // No need for Partial<Auth> unless you're passing the mock to something
  // that expects a full Auth object, which your services don't currently.
  // Just defining the methods you stub is sufficient.
  interface MockAuth {
    signInWithEmailAndPassword: sinon.SinonStub
    signOut: sinon.SinonStub
    createUserWithEmailAndPassword: sinon.SinonStub
    signInWithPopup: sinon.SinonStub
    // Add any other Firebase Auth properties/methods your services might *use*
    // (even if not stubbed in this test, the service function might try to access them)
    // For example, if a service function used auth.currentUser, you'd add:
    // currentUser: any; // Or a more specific User | null type
  }

  let mockAuth: MockAuth

  beforeEach(() => {
    // Re-create the mock object before each test
    mockAuth = {
      signInWithEmailAndPassword: sinon.stub(),
      signOut: sinon.stub(),
      createUserWithEmailAndPassword: sinon.stub(),
      signInWithPopup: sinon.stub(),
      // If adding currentUser:
      // currentUser: null, // Or a mock user if needed
    }
  })

  describe('login function', () => {
    it('should handle login errors correctly', async () => {
      const errorMessage = 'Login failed'
      // Mocking with a standard Error instance
      mockAuth.signInWithEmailAndPassword.rejects(new Error(errorMessage))

      try {
        // Note: You are passing mockAuth.signInWithEmailAndPassword as the signInFn,
        // but the function signature expects a type compatible with typeof signInWithEmailAndPassword.
        // Sinon stubs are usually compatible enough.
        await login(
          mockAuth as any, // Type assertion might be needed if MockAuth is too strict
          'test@example.com',
          'wrongpassword',
          mockAuth.signInWithEmailAndPassword as any, // Type assertion here too
        )
        // If the promise *wasn't* rejected, the test should fail
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (error: unknown) {
        // Error is unknown
        // Assert the error is an Error instance to access .message
        const err = error as Error
        expect(err.message).to.equal(errorMessage)
      }
    })

    it('should return user on successful login', async () => {
      const mockUser = { uid: '12345', email: 'test@example.com' }
      // Mocking the resolved value structure { user: ... }
      mockAuth.signInWithEmailAndPassword.resolves({ user: mockUser })

      const result = await login(
        mockAuth as any, // Type assertion if needed
        'test@example.com',
        'correctpassword',
        mockAuth.signInWithEmailAndPassword as any, // Type assertion if needed
      )
      // Your login service returns credential.user, which matches mockUser
      expect(result).to.deep.equal(mockUser)
    })
  })

  describe('logout function', () => {
    it('should call signOut and complete successfully', async () => {
      mockAuth.signOut.resolves()

      await logout(mockAuth as any, mockAuth.signOut as any) // Type assertions if needed

      expect(mockAuth.signOut).to.have.been.calledOnce
    })

    it('should handle errors during logout', async () => {
      const errorMessage = 'Logout failed'
      mockAuth.signOut.rejects(new Error(errorMessage)) // Mocking with Error instance

      try {
        await logout(mockAuth as any, mockAuth.signOut as any) // Type assertions if needed
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (error: unknown) {
        // Error is unknown
        const err = error as Error // Assert as Error
        expect(err.message).to.equal(errorMessage)
      }
    })
  })

  describe('register function', () => {
    it('should handle registration errors correctly', async () => {
      // Mocking with an object structure that mimics FirebaseError
      // Your register service catches this and re-throws a standard Error with a custom message
      mockAuth.createUserWithEmailAndPassword.rejects({
        code: 'auth/email-already-in-use',
        message: 'The email address is already in use.',
      })

      try {
        // The register function *under test* will throw an Error('This email is already registered.')
        await register(
          mockAuth as any,
          'existing-email@example.com',
          'password123',
          mockAuth.createUserWithEmailAndPassword as any,
        )
        throw new Error('Expected registration to fail')
      } catch (error: unknown) {
        // Error is unknown
        // The error caught *here* is the one re-thrown by your register service, which is an Error instance
        const err = error as Error // Assert as Error
        expect(err.message).to.equal(
          // Expect the specific error message your service re-throws
          'This email is already registered.',
        )
      }
    })

    it('should return user on successful registration', async () => {
      const mockUserCredential = {
        user: { email: 'new-user@example.com', uid: 'abc' },
      } // Add uid as user might have it
      mockAuth.createUserWithEmailAndPassword.resolves(mockUserCredential)

      const userCredential = await register(
        mockAuth as any, // Type assertion if needed
        'new-user@example.com',
        'password123',
        mockAuth.createUserWithEmailAndPassword as any, // Type assertion if needed
      )
      // Your register service returns the userCredential directly
      expect(userCredential).to.equal(mockUserCredential)
    })
  })

  describe('loginWithGoogle function', () => {
    it('should handle Google login errors correctly', async () => {
      const errorMessage = 'Google login failed'
      mockAuth.signInWithPopup.rejects(new Error(errorMessage)) // Mocking with Error instance

      try {
        // The loginWithGoogle function under test returns credential.user on success,
        // but throws the original error on failure.
        await loginWithGoogle(mockAuth as any, mockAuth.signInWithPopup as any) // Type assertions if needed
        throw new Error('Expected promise to be rejected, but it was resolved')
      } catch (error: unknown) {
        // Error is unknown
        const err = error as Error // Assert as Error (or FirebaseError if you want to check .code etc.)
        expect(err.message).to.equal(errorMessage)
      }
    })

    it('should return user on successful Google login', async () => {
      const mockUser = { uid: '12345', email: 'test@example.com' }
      mockAuth.signInWithPopup.resolves({ user: mockUser }) // Mocking resolved value structure { user: ... }

      const result = await loginWithGoogle(
        mockAuth as any,
        mockAuth.signInWithPopup as any,
      ) // Type assertions if needed
      // Your loginWithGoogle service returns credential.user, which matches mockUser
      expect(result).to.deep.equal(mockUser)
    })
  })
})


═══════════════════════════════════════════════
📄 FILE: ./src/services/authServices.ts
───────────────────────────────────────────────
// src/services/authServices.ts
import type { Auth, UserCredential, User } from 'firebase/auth'
import {
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  signInWithPopup,
  GoogleAuthProvider,
} from 'firebase/auth'
import type { FirebaseError } from 'firebase/app'

/* ------------------------------------------------------------------ */
/*  login                                                             */
/* ------------------------------------------------------------------ */
export const login = async (
  auth: Auth,
  email: string,
  password: string,
  signInFn: typeof signInWithEmailAndPassword = signInWithEmailAndPassword,
): Promise<UserCredential> => {
  return await signInFn(auth, email, password)
}

/* ------------------------------------------------------------------ */
/*  login with Google                                                 */
/* ------------------------------------------------------------------ */
export const loginWithGoogle = async (
  auth: Auth,
  // allow injection for testing; defaults to the real SDK fn
  popupFn: typeof signInWithPopup = signInWithPopup,
): Promise<User> => {
  const provider = new GoogleAuthProvider()
  const credential = await popupFn(auth, provider)
  return credential.user
}

/* ------------------------------------------------------------------ */
/*  logout                                                            */
/* ------------------------------------------------------------------ */
export const logout = async (
  auth: Auth,
  signOutFn: typeof signOut = signOut,
): Promise<void> => {
  await signOutFn(auth)
}

/* ------------------------------------------------------------------ */
/*  register                                                          */
/* ------------------------------------------------------------------ */
export const register = async (
  auth: Auth,
  email: string,
  password: string,
  createUserFn: typeof createUserWithEmailAndPassword = createUserWithEmailAndPassword,
): Promise<UserCredential> => {
  try {
    return await createUserFn(auth, email, password)
  } catch (err: unknown) {
    if (err && typeof err === 'object' && 'code' in err) {
      const firebaseError = err as FirebaseError
      if (firebaseError.code === 'auth/email-already-in-use') {
        throw new Error('This email is already registered.')
      }
      throw new Error(firebaseError.message)
    }
    throw new Error('Registration failed due to an unexpected error.')
  }
}


═══════════════════════════════════════════════
📄 FILE: ./src/services/firebaseMock.ts
───────────────────────────────────────────────
// src/services/firebaseAuthMock.js

import sinon from 'sinon'

export const mockAuth = {
  settings: {},
  signInWithEmailAndPassword: sinon.stub(),
  signOut: sinon.stub(),
  createUserWithEmailAndPassword: sinon.stub(),
  signInWithPopup: sinon.stub(),
}

export const resetAuthMocks = () => {
  mockAuth.signInWithEmailAndPassword.reset()
  mockAuth.signOut.reset()
  mockAuth.createUserWithEmailAndPassword.reset()
  mockAuth.signInWithPopup.reset()
}


═══════════════════════════════════════════════
📄 FILE: ./src/shim-vue.d.ts
───────────────────────────────────────────────
// src/shim-vue.d.ts
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-explicit-any
  const component: DefineComponent<{}, {}, any>
  export default component
}


═══════════════════════════════════════════════
📄 FILE: ./tailwind.config.js
───────────────────────────────────────────────
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx,vue}'],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#1f2937',
          hover: '#111827',
          light: '#374151',
          dark: '#0f172a',
        },
        secondary: {
          DEFAULT: '#64748b',
          light: '#94a3b8',
          dark: '#475569',
        },
        accent: {
          DEFAULT: '#ff9f1c',
          light: '#ffb347',
          dark: '#cc7a00',
        },
        success: {
          DEFAULT: '#22c55e',
          light: '#4ade80',
          dark: '#15803d',
        },
        error: {
          DEFAULT: '#ef4444',
          light: '#f87171',
          dark: '#b91c1c',
        },
        warning: {
          DEFAULT: '#facc15',
          light: '#fde047',
          dark: '#ca8a04',
        },
        info: {
          DEFAULT: '#0ea5e9',
          light: '#38bdf8',
          dark: '#0369a1',
        },
        background: {
          DEFAULT: '#f8fafc',
          dark: '#1e293b',
        },
        surface: {
          DEFAULT: '#ffffff',
          dark: '#111827',
        },
        border: {
          DEFAULT: '#e2e8f0',
          dark: '#334155',
        },
        text: {
          primary: '#1e293b',
          secondary: '#64748b',
          tertiary: '#718096',
          inverted: '#ffffff',
        },
        muted: '#f1f5f9',
      },
      spacing: {
        xs: '0.25rem',
        sm: '0.5rem',
        md: '1rem',
        lg: '1.5rem',
        xl: '2rem',
      },
      borderRadius: {
        sm: '0.375rem',
        md: '0.5rem',
        lg: '1rem',
        xl: '1.5rem',
      },
      boxShadow: {
        sm: '0 1px 3px rgba(0, 0, 0, 0.12)',
        md: '0 4px 6px rgba(0, 0, 0, 0.1)',
        lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
        xl: '0 15px 25px rgba(0, 0, 0, 0.15)',
      },
      transitionDuration: {
        fast: '150ms',
        normal: '250ms',
        slow: '400ms',
      },
      transitionTimingFunction: {
        ease: 'ease',
        'ease-in': 'ease-in',
        'ease-out': 'ease-out',
      },
      container: {
        center: true,
        padding: {
          DEFAULT: '1rem',
          sm: '1rem',
          lg: '2rem',
          xl: '2rem',
        },
      },
    },
  },
  plugins: [],
}


